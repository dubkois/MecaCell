#ifndef MECACELL_ELASTICCONNECTION_HPP
#define MECACELL_ELASTICCONNECTION_HPP
#include <cmath>
#include <utility>
#include "spring.hpp"
#include "utilities/ordered_pair.hpp"
#include "utilities/utils.h"

namespace MecaCell {
/**
 * @brief An Elastic Connection is a connection between two cells that aims to models both
 * attractive (for adhesion) and repulsive (for collision) forces. It is composed of
 *  - a collision response using Hertz contact force
 *  - an adhesion response modeled using 3 springs (1 straight, 2 rotational) whose params
 *
 * @tparam Cell a connectable cell class.
 * Required methods for Cell:
 * - Vec getPosition()
 * - Vec getVelocity()
 * - Vec getAngularVelocity()
 * - Basis getOrientation()
 * - Rotation getOrientationRotation()
 * - double getInertia()
 * - void receiveForce(double intensity, Vec direction, bool compressive)
 * - void receiveTorque(Vec acc)
 * An implementaiton of these methods is available in the Orientable and Movable classes.
 */

template <typename Cell> struct ElasticConnection {
	static const constexpr double COLLISION_DAMPING_RATIO = 0.5;
	static const constexpr double ANGULAR_ADH_RATIO = 10.0;
	static const constexpr double ADH_DAMPING_RATIO = 1.0;
	static const constexpr double ADH_CONSTANT =
	    0.005 * Config::DEFAULT_CELL_STIFFNESS;  // factor by which all adhesion forces is
	                                             // multiplied
	static const constexpr double MAX_TS_INCL =
	    0.1;  // max angle before we need to reproject our torsion joint rotation

	ordered_pair<Cell *> cells;
	Spring adhesion;
	double area = 0;  // area of the contact disk
	double invertRadii = 0;
	double invertYoung = 0;
	std::pair<double, double>
	    midpoint;        // contact disk's distance to center (viewed from each cell)
	Vector3D direction;  // normalized direction from cell 0 to cell 1
	double dist;         // distance btwn the two cells
	std::pair<Joint, Joint> flex, tors;
	bool adhesionEnabled = true, frictionEnabled = true, torsEnabled = false,
	     fixedAdhesion = false;

	ElasticConnection(){};
	ElasticConnection(ordered_pair<Cell *> c) : cells(c) { init(); };

	void updateDirection() {
		direction = cells.second->getPosition() - cells.first->getPosition();
		dist = direction.length();
		if (dist > 0) direction /= dist;
		midpoint = computeMidpoints();
	}

	std::pair<double, double> computeMidpoints() {
		// return the current contact disk's center distance to each cells centers
		if (dist <= Config::DOUBLE_EPSILON) return {0, 0};

		auto biggestCell = cells.first->getBody().getBoundingBoxRadius() >=
		                           cells.second->getBody().getBoundingBoxRadius() ?
		                       cells.first :
		                       cells.second;
		auto smallestCell = biggestCell == cells.first ? cells.second : cells.first;

		double biggestCellMidpoint =
		    0.5 * (dist +
		           (std::pow(biggestCell->getBody().getBoundingBoxRadius(), 2) -
		            std::pow(smallestCell->getBody().getBoundingBoxRadius(), 2)) /
		               dist);
		double smallestCellMidpoint = dist - biggestCellMidpoint;
		if (biggestCell == cells.first)
			return {biggestCellMidpoint, smallestCellMidpoint};
		else
			return {smallestCellMidpoint, biggestCellMidpoint};
	}

	void updateCollisionForces() {
		double overlap = max(0.0, (cells.first->getBoundingBoxRadius() +
		                           cells.second->getBoundingBoxRadius()) -
		                              dist);
		const auto &c0 = cells.first->getBody();
		const auto &c1 = cells.first->getBody();
		invertRadii = 1.0 / (1.0 / cells.first->getBoundingBoxRadius() +
		                     1.0 / cells.second->getBoundingBoxRadius());
		invertYoung = 1.0 / (((1.0 - pow(c0.getPoissonCoef(), 2)) / c0.getYoungModulus()) +
		                     ((1.0 - pow(c1.getPoissonCoef(), 2)) / c1.getYoungModulus()));
		double tempterm = sqrt(invertRadii) * pow(overlap, 3.0 / 2.0);
		area = pow(cbrt(invertRadii * tempterm), 2) * M_PI;
		auto F = direction * ((2.0 / 3.0) * invertYoung * tempterm);
		cells.first->receiveForce(-F);
		cells.second->receiveForce(F);
	}

	void updateAdhesionForces(double dt) {
		adhesion.updateLength(dist);
		double adhCoef = min(
		    cells.first->getAdhesionWith(
		        cells.second,
		        direction.rotated(
		            cells.first->getBody().getOrientationRotation().inverted())),
		    cells.second->getAdhesionWith(
		        cells.first,
		        (-direction)
		            .rotated(cells.second->getBody().getOrientationRotation().inverted())));
		adhesion.k = area * ADH_CONSTANT * adhCoef;
		adhesion.c = dampingFromRatio(
		    ADH_DAMPING_RATIO, cells.first->getMass() + cells.second->getMass(), adhesion.k);
		adhesion.applyForce(*(cells.first), *(cells.second), direction, dt);
	}

	void initJoints() {
		auto ortho = direction.ortho();
		// rotations for joints (cell base to connection) =
		// cellBasis -> worldBasis + worldBasis -> connectionBasis
		flex.first.r = cells.first->getBody().getOrientationRotation().inverted() +
		               Vec::getRotation(Basis<Vec>(), Basis<Vec>(direction, ortho));
		flex.second.r = cells.second->getBody().getOrientationRotation().inverted() +
		                Vec::getRotation(Basis<Vec>(), Basis<Vec>(direction, ortho));
		tors.first.r = flex.first.r;
		tors.second.r = flex.second.r;

		updateFlexParams();
		updateTorsParams();
	}

	void updateTorsParams() {
		tors.first.updateDirection(cells.first->getBody().getOrientation().Y,
		                           cells.first->getBody().getOrientationRotation());
		tors.second.updateDirection(cells.second->getBody().getOrientation().Y,
		                            cells.second->getBody().getOrientationRotation());
		tors.first.k = adhesion.k * ANGULAR_ADH_RATIO;
		tors.second.k = adhesion.k * ANGULAR_ADH_RATIO;
		tors.first.c = dampingFromRatio(ADH_DAMPING_RATIO,
		                                cells.first->getBody().getMomentOfInertia() +
		                                    cells.second->getBody().getMomentOfInertia(),
		                                tors.first.k);
		tors.second.c = tors.first.c;
	}

	void updateFlexParams() {
		flex.first.updateDirection(cells.first->getBody().getOrientation().X,
		                           cells.first->getBody().getOrientationRotation());
		flex.second.updateDirection(cells.second->getBody().getOrientation().X,
		                            cells.second->getBody().getOrientationRotation());
		flex.first.k = adhesion.k * ANGULAR_ADH_RATIO;
		flex.second.k = adhesion.k * ANGULAR_ADH_RATIO;
		flex.first.c = dampingFromRatio(ADH_DAMPING_RATIO,
		                                cells.first->getBody().getMomentOfInertia() +
		                                    cells.second->getBody().getMomentOfInertia(),
		                                flex.first.k);
		flex.second.c = flex.first.c;
	}

	void init() {
		updateDirection();
		if (adhesionEnabled) {
			adhesion.length = dist;
			adhesion.prevLength = dist;
			adhesion.restLength = 0;
			initJoints();
		}
	}

	template <int n> void updateJointsForces(double dt) {
		Joint &torsNode = n == 0 ? tors.first : tors.second;
		Joint &torsOther = n == 0 ? tors.second : tors.first;
		Joint &flexNode = n == 0 ? flex.first : flex.second;
		const auto &cell = cells.template get<n>();
		const auto &other = cells.template get < n == 0 ? 1 : 0 > ();
		const double sign = n == 0 ? 1 : -1;
		if (flexNode.targetUpdateEnabled) flexNode.target = direction * sign;
		flexNode.updateDelta();
		if (flexNode.maxTetaAutoCorrect &&
		    flexNode.delta.teta > flexNode.maxTeta) {  // if we passed flex break angle
			double dif = flexNode.delta.teta - flexNode.maxTeta;
			flexNode.r = flexNode.r + Rotation<Vec>(flexNode.delta.n, dif);
			flexNode.direction =
			    flexNode.direction.rotated(Rotation<Vec>(flexNode.delta.n, dif));
			flexNode.r = cell->getBody().getOrientationRotation().inverted() +
			             Vec::getRotation(Basis<Vec>(), Basis<Vec>(flexNode.direction,
			                                                       flexNode.direction.ortho()));
		}
		double torque =
		    flexNode.k * flexNode.delta.teta +
		    flexNode.c * ((flexNode.delta.teta - flexNode.prevDelta.teta) / dt);  // -kx - cv
		logger<DBG>("torque = ", torque);
		Vec vFlex = flexNode.delta.n * torque;                       // torque
		Vec ortho = direction.ortho(flexNode.delta.n).normalized();  // force direction
		Vec force = sign * ortho * torque / dist;

		cell->receiveForce(-force);
		other->receiveForce(force);

		cell->getBody().receiveTorque(vFlex);
		flexNode.prevDelta = flexNode.delta;
		if (torsEnabled) {
			// updating torsion joint (needs to stay perp to direction)
			double scalar = torsNode.direction.dot(direction);
			// if the angle between our torsion spring and direction is too far from 90°,
			// we reproject & recompute it
			if (abs(scalar) > MAX_TS_INCL) {
				torsNode.r = cell->getBody().getOrientationRotation().inverted() +
				             Vec::getRotation(Basis<Vec>(Vec(1, 0, 0), Vec(0, 1, 0)),
				                              Basis<Vec>(direction, torsNode.direction));
			} else
				torsNode.direction = torsNode.direction.normalized() - scalar * direction;
			// updating targets
			torsNode.target =
			    torsOther.direction;  // we want torsion springs to stay aligned with each other
			torsNode.updateDelta();
			// torsion torque
			double torque = torsNode.k * torsNode.delta.teta;  // - torsNode.c *
			// cell->getAngularVelocity().dot(torsNode.delta.teta.n)
			Vec vTorsion = torque * torsNode.delta.n;
			cell->getBody().receiveTorque(vTorsion);
		}
	}
	void update(double dt) {
		updateDirection();
		updateCollisionForces();
		if (adhesionEnabled) {
			updateAdhesionForces(dt);
			updateFlexParams();
			if (torsEnabled) updateTorsParams();
			updateJointsForces<0>(dt);
			updateJointsForces<1>(dt);
		}
	}
	// ALGO POUR CONNECTIONS
	// raisonner en surface : il y a une surface d'adhésion en un instant T, et une
	// histérésie pour la création / suppression de liens.
	// on a une distance de création de nouveau liens bondReachDist, une distance de casse
	// bondBreakDist. La force de rappel c'est en permanence
	// le delta surface d'adhésion * la distance qu'il faudrait pour atteindre la surface
	// cible. Ça c'est pour l'adhésion dans l'axe.
	// Ensuite pour garder les contraintes en rotation, on utilise les joints, mais juste
	// pour le calcul de l'angle, c'est pas des ressorts classiques. On se sert de l'angle
	// pour calculer le barycentre de tous les liens qui sont allongés à cause de la
	// rotation. Quand on l'a, on applique aux membranes une force de rappel qui sera donc
	// colinéaire à la force de rejet mais excentrée.
	//
	// \=====/  <-- force de rappel au barycentre  de l'élongation (donc torque + f)
	//  \===/
	//   \-/
	//    |
	//    | --> force de rejet au centre de la surface de contact (donc direct aux centres)
	//    |
	//
};
}
#endif
